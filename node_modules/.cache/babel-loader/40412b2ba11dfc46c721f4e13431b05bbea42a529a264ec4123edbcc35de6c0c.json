{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// Add a simple ping function to check API connectivity\nexport const checkApiConnection = async () => {\n  var _localStorage$getItem;\n  console.log('Checking API connectivity');\n  const connectionInfo = {\n    apiBaseUrl: API_BASE_URL,\n    checks: [],\n    systemInfo: {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      connectionType: navigator.connection ? navigator.connection.effectiveType : 'unknown'\n    },\n    auth: {\n      hasToken: !!localStorage.getItem('token'),\n      tokenLength: ((_localStorage$getItem = localStorage.getItem('token')) === null || _localStorage$getItem === void 0 ? void 0 : _localStorage$getItem.length) || 0\n    },\n    startTime: new Date().toISOString()\n  };\n  try {\n    // Check 1: Simple connectivity check - OPTIONS request\n    connectionInfo.checks.push({\n      name: 'Basic OPTIONS Request',\n      endpoint: '/',\n      method: 'OPTIONS',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const optionsResponse = await axios.options(`${API_BASE_URL}/`);\n      connectionInfo.checks[0].status = 'success';\n      connectionInfo.checks[0].statusCode = optionsResponse.status;\n      connectionInfo.checks[0].headers = optionsResponse.headers;\n    } catch (error) {\n      connectionInfo.checks[0].status = 'error';\n      connectionInfo.checks[0].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[0].endTime = new Date().toISOString();\n\n    // Check 2: Auth status endpoint\n    connectionInfo.checks.push({\n      name: 'Auth Status Endpoint',\n      endpoint: '/auth/status',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const statusResponse = await axios.get(`${API_BASE_URL}/auth/status`);\n      connectionInfo.checks[1].status = 'success';\n      connectionInfo.checks[1].statusCode = statusResponse.status;\n      connectionInfo.checks[1].data = statusResponse.data;\n      connectionInfo.checks[1].message = 'Server is online';\n      connectionInfo.serverStatus = statusResponse.data.status;\n    } catch (error) {\n      connectionInfo.checks[1].status = 'error';\n      connectionInfo.checks[1].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n      connectionInfo.serverStatus = 'unknown';\n    }\n    connectionInfo.checks[1].endTime = new Date().toISOString();\n\n    // Check 3: Try the auth login endpoint\n    connectionInfo.checks.push({\n      name: 'Auth Login Endpoint',\n      endpoint: '/auth/login',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      // Just check if the endpoint exists without sending credentials\n      const authEndpointResponse = await axios.get(`${API_BASE_URL}/auth/login`, {\n        validateStatus: status => status < 500 // Allow 4xx responses\n      });\n\n      // Even 401 or 405 means the endpoint exists\n      connectionInfo.checks[2].status = 'success';\n      connectionInfo.checks[2].statusCode = authEndpointResponse.status;\n      connectionInfo.checks[2].message = 'Auth endpoint exists (returned ' + authEndpointResponse.status + ')';\n    } catch (error) {\n      connectionInfo.checks[2].status = 'error';\n      connectionInfo.checks[2].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[2].endTime = new Date().toISOString();\n\n    // Check 4: Try the tickets endpoint\n    connectionInfo.checks.push({\n      name: 'Tickets Endpoint',\n      endpoint: '/tickets',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const ticketsResponse = await axios.get(`${API_BASE_URL}/tickets`, {\n        validateStatus: status => status < 500,\n        // Allow 4xx responses\n        headers: {\n          // Add token if available\n          ...(localStorage.getItem('token') ? {\n            Authorization: `Bearer ${localStorage.getItem('token')}`\n          } : {})\n        }\n      });\n\n      // Even 401 is OK - it means the endpoint exists\n      const endpointExists = ticketsResponse.status !== 404;\n      connectionInfo.checks[3].status = endpointExists ? 'success' : 'error';\n      connectionInfo.checks[3].statusCode = ticketsResponse.status;\n      connectionInfo.checks[3].message = `Tickets endpoint ${endpointExists ? 'exists' : 'does not exist'} (${ticketsResponse.status})`;\n      if (ticketsResponse.status === 200) {\n        connectionInfo.checks[3].dataType = typeof ticketsResponse.data;\n        connectionInfo.checks[3].dataStructure = Array.isArray(ticketsResponse.data) ? 'array' : typeof ticketsResponse.data;\n      }\n    } catch (error) {\n      connectionInfo.checks[3].status = 'error';\n      connectionInfo.checks[3].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[3].endTime = new Date().toISOString();\n\n    // Check 5: Try the root API endpoint\n    connectionInfo.checks.push({\n      name: 'Root API Check',\n      endpoint: '/',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const rootResponse = await axios.get(`${API_BASE_URL}`, {\n        validateStatus: status => status < 500 // Allow 4xx responses\n      });\n      connectionInfo.checks[4].status = 'success';\n      connectionInfo.checks[4].statusCode = rootResponse.status;\n      connectionInfo.checks[4].message = `Root API endpoint response: ${rootResponse.status}`;\n    } catch (error) {\n      connectionInfo.checks[4].status = 'error';\n      connectionInfo.checks[4].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[4].endTime = new Date().toISOString();\n\n    // Check if server appears to be running at all\n    connectionInfo.summary = {\n      serverRunning: connectionInfo.checks.some(c => c.status === 'success'),\n      authEndpointConfigured: false,\n      ticketsEndpointConfigured: false,\n      possibleIssues: []\n    };\n\n    // Check if auth appears to be properly configured\n    const authEndpointExists = connectionInfo.checks[2].status === 'success';\n\n    // Add summary\n    connectionInfo.summary.authEndpointConfigured = authEndpointExists;\n    connectionInfo.summary.ticketsEndpointConfigured = connectionInfo.checks.some(c => c.name === 'Tickets Endpoint' && c.status === 'success');\n\n    // Add possible issues\n    if (!connectionInfo.summary.serverRunning) {\n      connectionInfo.summary.possibleIssues.push('Server does not appear to be running');\n    }\n    if (authEndpointExists && connectionInfo.checks[2].statusCode === 404) {\n      connectionInfo.summary.possibleIssues.push('Auth endpoint not found - check backend routes configuration');\n    }\n    connectionInfo.endTime = new Date().toISOString();\n\n    // Determine overall status\n    if (!connectionInfo.summary.serverRunning) {\n      connectionInfo.overallStatus = 'server_unreachable';\n    } else if (connectionInfo.checks.every(c => c.statusCode === 404)) {\n      connectionInfo.overallStatus = 'wrong_api_base_url';\n    } else if (!connectionInfo.summary.authEndpointConfigured) {\n      connectionInfo.overallStatus = 'auth_endpoint_missing';\n    } else {\n      connectionInfo.overallStatus = 'server_reachable';\n    }\n    return connectionInfo;\n  } catch (error) {\n    connectionInfo.endTime = new Date().toISOString();\n    connectionInfo.overallStatus = 'check_failed';\n    connectionInfo.error = {\n      message: error.message,\n      stack: error.stack\n    };\n    return connectionInfo;\n  }\n};\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true\n});\n\n// Add token to requests if it exists\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem('token');\n  if (token && config.headers) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\nexport const login = async (username, password) => {\n  const response = await api.post('/auth/login', {\n    username,\n    password\n  });\n  return response.data;\n};\nexport const createTicket = async ticketData => {\n  const formData = new FormData();\n\n  // Add ticket data\n  formData.append('title', ticketData.title);\n  formData.append('description', ticketData.description);\n  formData.append('requesterId', ticketData.requesterId);\n  formData.append('department', ticketData.department);\n  formData.append('chemicalConfig', JSON.stringify(ticketData.chemicalConfig));\n\n  // Add files if they exist\n  if (ticketData.attachments && ticketData.attachments instanceof FileList) {\n    Array.from(ticketData.attachments).forEach(file => {\n      formData.append('files', file);\n    });\n  }\n  const response = await api.post('/tickets', formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    }\n  });\n  return response.data;\n};\n\n// New function to get tickets without date filtering for debugging\nexport const getAllTicketsRaw = async () => {\n  console.log('Fetching all tickets raw for debugging');\n  const debugInfo = {\n    requestInfo: {},\n    responseInfo: {},\n    error: null,\n    attempts: []\n  };\n  try {\n    // Get auth token info\n    const token = localStorage.getItem('token');\n    debugInfo.requestInfo.auth = {\n      hasToken: !!token,\n      tokenLength: token ? token.length : 0,\n      tokenStart: token ? token.substring(0, 10) + '...' : 'none'\n    };\n\n    // Try multiple variations of API calls to diagnose the issue\n\n    // Attempt 1: Basic call without params\n    console.log('DEBUG attempt 1: Basic call without params');\n    debugInfo.attempts.push({\n      name: 'Basic Call',\n      url: '/tickets',\n      params: {},\n      startTime: new Date().toISOString()\n    });\n    let response = await api.get('/tickets');\n    debugInfo.attempts[0].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[0].endTime = new Date().toISOString();\n\n    // Attempt 2: With pagination params only\n    console.log('DEBUG attempt 2: With pagination params only');\n    const params = {\n      page: '1',\n      limit: '100'\n    };\n    debugInfo.attempts.push({\n      name: 'Pagination Only',\n      url: '/tickets',\n      params,\n      startTime: new Date().toISOString()\n    });\n    response = await api.get('/tickets', {\n      params\n    });\n    debugInfo.attempts[1].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[1].endTime = new Date().toISOString();\n\n    // Attempt 3: With modified date range (all time)\n    console.log('DEBUG attempt 3: With all-time date range');\n    const dateParams = {\n      page: '1',\n      limit: '100',\n      startDate: '2020-01-01',\n      endDate: new Date().toISOString()\n    };\n    debugInfo.attempts.push({\n      name: 'All-Time Date Range',\n      url: '/tickets',\n      params: dateParams,\n      startTime: new Date().toISOString()\n    });\n    response = await api.get('/tickets', {\n      params: dateParams\n    });\n    debugInfo.attempts[2].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[2].endTime = new Date().toISOString();\n\n    // Return the combined debug info\n    return {\n      success: true,\n      debugInfo,\n      mainResponse: response.data\n    };\n  } catch (error) {\n    console.error('Error in raw ticket fetch:', error);\n    debugInfo.error = {\n      message: error.message,\n      stack: error.stack,\n      response: error.response ? {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data\n      } : null\n    };\n    return {\n      success: false,\n      error: error.message,\n      debugInfo\n    };\n  }\n};\nexport const getTickets = async (status, page = 1, limit = 10, dateRange) => {\n  try {\n    // Build query parameters\n    const params = {\n      page: page.toString(),\n      limit: limit.toString()\n    };\n    if (status) {\n      params.status = status;\n    }\n\n    // Add date filter parameters if provided\n    if (dateRange) {\n      // Format dates as ISO strings and extract just the date part for consistency\n      params.startDate = dateRange.startDate.toISOString().split('T')[0];\n\n      // For end date, ensure we're capturing the full day by setting time to end of day\n      const endDate = new Date(dateRange.endDate);\n      endDate.setHours(23, 59, 59, 999);\n      params.endDate = endDate.toISOString();\n      console.log('API call with date range:', {\n        startDate: params.startDate,\n        endDate: params.endDate\n      });\n    } else {\n      console.log('API call with no date range provided');\n    }\n    const queryString = new URLSearchParams(params).toString();\n    console.log(`Fetching tickets with params: ${queryString}`);\n    const response = await api.get(`/tickets?${queryString}`);\n\n    // Add more detailed logging\n    console.log('API response type:', typeof response.data);\n    console.log('API response keys:', Object.keys(response.data || {}));\n\n    // Check if response has the expected structure\n    if (response.data && response.data.tickets && Array.isArray(response.data.tickets)) {\n      console.log(`Found ${response.data.tickets.length} tickets in response`);\n      return response.data;\n    }\n\n    // Handle case where response is directly an array of tickets\n    if (Array.isArray(response.data)) {\n      console.log(`Response is an array with ${response.data.length} tickets`);\n      return {\n        tickets: response.data,\n        pagination: {\n          page,\n          limit,\n          total: response.data.length,\n          totalPages: Math.ceil(response.data.length / limit)\n        }\n      };\n    }\n\n    // Handle empty or unexpected response\n    console.warn('Unexpected response format:', response.data);\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      }\n    };\n  } catch (error) {\n    var _error$response;\n    console.error('Error fetching tickets:', error);\n    console.error('Error details:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n\n    // Return empty data structure instead of throwing\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      },\n      error: error.message\n    };\n  }\n};\nexport const updateTicketStatus = async (ticketId, status) => {\n  const response = await api.put(`/tickets/${ticketId}`, {\n    status\n  });\n  return response.data;\n};\nexport const updateTicket = async (ticketId, updateData) => {\n  const formData = new FormData();\n\n  // Add basic ticket data if provided\n  if (updateData.title) formData.append('title', updateData.title);\n  if (updateData.description) formData.append('description', updateData.description);\n  if (updateData.status) formData.append('status', updateData.status);\n  if (updateData.department) formData.append('department', updateData.department);\n  if (updateData.chemicalConfig) formData.append('chemicalConfig', JSON.stringify(updateData.chemicalConfig));\n\n  // Add new files if they exist\n  if (updateData.attachments && Array.isArray(updateData.attachments)) {\n    updateData.attachments.forEach(file => {\n      if (file instanceof File) {\n        formData.append('files', file);\n      }\n    });\n  }\n  const response = await api.put(`/tickets/${ticketId}`, formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    }\n  });\n  return response.data;\n};\nexport default api;","map":{"version":3,"names":["axios","API_BASE_URL","checkApiConnection","_localStorage$getItem","console","log","connectionInfo","apiBaseUrl","checks","systemInfo","userAgent","navigator","platform","language","connectionType","connection","effectiveType","auth","hasToken","localStorage","getItem","tokenLength","length","startTime","Date","toISOString","push","name","endpoint","method","status","optionsResponse","options","statusCode","headers","error","message","code","endTime","statusResponse","get","data","serverStatus","response","authEndpointResponse","validateStatus","ticketsResponse","Authorization","endpointExists","dataType","dataStructure","Array","isArray","rootResponse","summary","serverRunning","some","c","authEndpointConfigured","ticketsEndpointConfigured","possibleIssues","authEndpointExists","overallStatus","every","stack","api","create","baseURL","withCredentials","interceptors","request","use","config","token","login","username","password","post","createTicket","ticketData","formData","FormData","append","title","description","requesterId","department","JSON","stringify","chemicalConfig","attachments","FileList","from","forEach","file","getAllTicketsRaw","debugInfo","requestInfo","responseInfo","attempts","tokenStart","substring","url","params","statusText","page","limit","dateParams","startDate","endDate","success","mainResponse","getTickets","dateRange","toString","split","setHours","queryString","URLSearchParams","Object","keys","tickets","pagination","total","totalPages","Math","ceil","warn","_error$response","updateTicketStatus","ticketId","put","updateTicket","updateData","File"],"sources":["/Users/a667227/Desktop/Work/ticket-management/src/services/api.ts"],"sourcesContent":["import axios, { InternalAxiosRequestConfig } from 'axios';\nimport { Ticket, TicketStatus } from '../types/system';\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// Add a simple ping function to check API connectivity\nexport const checkApiConnection = async (): Promise<any> => {\n  console.log('Checking API connectivity');\n  const connectionInfo: any = {\n    apiBaseUrl: API_BASE_URL,\n    checks: [],\n    systemInfo: {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      connectionType: (navigator as any).connection ? \n        (navigator as any).connection.effectiveType : 'unknown'\n    },\n    auth: {\n      hasToken: !!localStorage.getItem('token'),\n      tokenLength: localStorage.getItem('token')?.length || 0\n    },\n    startTime: new Date().toISOString()\n  };\n  \n  try {\n    // Check 1: Simple connectivity check - OPTIONS request\n    connectionInfo.checks.push({\n      name: 'Basic OPTIONS Request',\n      endpoint: '/',\n      method: 'OPTIONS',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const optionsResponse = await axios.options(`${API_BASE_URL}/`);\n      connectionInfo.checks[0].status = 'success';\n      connectionInfo.checks[0].statusCode = optionsResponse.status;\n      connectionInfo.checks[0].headers = optionsResponse.headers;\n    } catch (error: any) {\n      connectionInfo.checks[0].status = 'error';\n      connectionInfo.checks[0].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[0].endTime = new Date().toISOString();\n    \n    // Check 2: Auth status endpoint\n    connectionInfo.checks.push({\n      name: 'Auth Status Endpoint',\n      endpoint: '/auth/status',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const statusResponse = await axios.get(`${API_BASE_URL}/auth/status`);\n      connectionInfo.checks[1].status = 'success';\n      connectionInfo.checks[1].statusCode = statusResponse.status;\n      connectionInfo.checks[1].data = statusResponse.data;\n      connectionInfo.checks[1].message = 'Server is online';\n      connectionInfo.serverStatus = statusResponse.data.status;\n    } catch (error: any) {\n      connectionInfo.checks[1].status = 'error';\n      connectionInfo.checks[1].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n      connectionInfo.serverStatus = 'unknown';\n    }\n    connectionInfo.checks[1].endTime = new Date().toISOString();\n    \n    // Check 3: Try the auth login endpoint\n    connectionInfo.checks.push({\n      name: 'Auth Login Endpoint',\n      endpoint: '/auth/login',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      // Just check if the endpoint exists without sending credentials\n      const authEndpointResponse = await axios.get(`${API_BASE_URL}/auth/login`, {\n        validateStatus: (status) => status < 500 // Allow 4xx responses\n      });\n      \n      // Even 401 or 405 means the endpoint exists\n      connectionInfo.checks[2].status = 'success';\n      connectionInfo.checks[2].statusCode = authEndpointResponse.status;\n      connectionInfo.checks[2].message = 'Auth endpoint exists (returned ' + authEndpointResponse.status + ')';\n    } catch (error: any) {\n      connectionInfo.checks[2].status = 'error';\n      connectionInfo.checks[2].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[2].endTime = new Date().toISOString();\n    \n    // Check 4: Try the tickets endpoint\n    connectionInfo.checks.push({\n      name: 'Tickets Endpoint',\n      endpoint: '/tickets',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const ticketsResponse = await axios.get(`${API_BASE_URL}/tickets`, {\n        validateStatus: (status) => status < 500, // Allow 4xx responses\n        headers: { \n          // Add token if available\n          ...(localStorage.getItem('token') \n            ? { Authorization: `Bearer ${localStorage.getItem('token')}` } \n            : {})\n        }\n      });\n      \n      // Even 401 is OK - it means the endpoint exists\n      const endpointExists = ticketsResponse.status !== 404;\n      connectionInfo.checks[3].status = endpointExists ? 'success' : 'error';\n      connectionInfo.checks[3].statusCode = ticketsResponse.status;\n      connectionInfo.checks[3].message = `Tickets endpoint ${endpointExists ? 'exists' : 'does not exist'} (${ticketsResponse.status})`;\n      \n      if (ticketsResponse.status === 200) {\n        connectionInfo.checks[3].dataType = typeof ticketsResponse.data;\n        connectionInfo.checks[3].dataStructure = Array.isArray(ticketsResponse.data) ? \n          'array' : typeof ticketsResponse.data;\n      }\n    } catch (error: any) {\n      connectionInfo.checks[3].status = 'error';\n      connectionInfo.checks[3].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[3].endTime = new Date().toISOString();\n    \n    // Check 5: Try the root API endpoint\n    connectionInfo.checks.push({\n      name: 'Root API Check',\n      endpoint: '/',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const rootResponse = await axios.get(`${API_BASE_URL}`, {\n        validateStatus: (status) => status < 500 // Allow 4xx responses\n      });\n      \n      connectionInfo.checks[4].status = 'success';\n      connectionInfo.checks[4].statusCode = rootResponse.status;\n      connectionInfo.checks[4].message = `Root API endpoint response: ${rootResponse.status}`;\n    } catch (error: any) {\n      connectionInfo.checks[4].status = 'error';\n      connectionInfo.checks[4].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[4].endTime = new Date().toISOString();\n    \n    // Check if server appears to be running at all\n    connectionInfo.summary = {\n      serverRunning: connectionInfo.checks.some((c: any) => c.status === 'success'),\n      authEndpointConfigured: false,\n      ticketsEndpointConfigured: false,\n      possibleIssues: []\n    };\n    \n    // Check if auth appears to be properly configured\n    const authEndpointExists = connectionInfo.checks[2].status === 'success';\n    \n    // Add summary\n    connectionInfo.summary.authEndpointConfigured = authEndpointExists;\n    connectionInfo.summary.ticketsEndpointConfigured = \n      connectionInfo.checks.some((c: any) => c.name === 'Tickets Endpoint' && c.status === 'success');\n    \n    // Add possible issues\n    if (!connectionInfo.summary.serverRunning) {\n      connectionInfo.summary.possibleIssues.push('Server does not appear to be running');\n    }\n    \n    if (authEndpointExists && connectionInfo.checks[2].statusCode === 404) {\n      connectionInfo.summary.possibleIssues.push('Auth endpoint not found - check backend routes configuration');\n    }\n    \n    connectionInfo.endTime = new Date().toISOString();\n    \n    // Determine overall status\n    if (!connectionInfo.summary.serverRunning) {\n      connectionInfo.overallStatus = 'server_unreachable';\n    } else if (connectionInfo.checks.every(c => c.statusCode === 404)) {\n      connectionInfo.overallStatus = 'wrong_api_base_url';\n    } else if (!connectionInfo.summary.authEndpointConfigured) {\n      connectionInfo.overallStatus = 'auth_endpoint_missing';\n    } else {\n      connectionInfo.overallStatus = 'server_reachable';\n    }\n    \n    return connectionInfo;\n  } catch (error: any) {\n    connectionInfo.endTime = new Date().toISOString();\n    connectionInfo.overallStatus = 'check_failed';\n    connectionInfo.error = {\n      message: error.message,\n      stack: error.stack\n    };\n    return connectionInfo;\n  }\n};\n\nexport interface LoginResponse {\n  token: string;\n  user: {\n    id: string;\n    username: string;\n    email: string;\n    fullName: string;\n    role: string;\n    department: string;\n  };\n}\n\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  withCredentials: true\n});\n\n// Add token to requests if it exists\napi.interceptors.request.use((config: InternalAxiosRequestConfig) => {\n  const token = localStorage.getItem('token');\n  if (token && config.headers) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\n\nexport const login = async (username: string, password: string): Promise<LoginResponse> => {\n  const response = await api.post<LoginResponse>('/auth/login', { username, password });\n  return response.data;\n};\n\nexport const createTicket = async (ticketData: Omit<Ticket, 'id' | 'status' | 'createdAt' | 'updatedAt'>): Promise<Ticket> => {\n  const formData = new FormData();\n  \n  // Add ticket data\n  formData.append('title', ticketData.title);\n  formData.append('description', ticketData.description);\n  formData.append('requesterId', ticketData.requesterId);\n  formData.append('department', ticketData.department);\n  formData.append('chemicalConfig', JSON.stringify(ticketData.chemicalConfig));\n  \n  // Add files if they exist\n  if (ticketData.attachments && ticketData.attachments instanceof FileList) {\n    Array.from(ticketData.attachments).forEach(file => {\n      formData.append('files', file);\n    });\n  }\n\n  const response = await api.post<Ticket>('/tickets', formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data',\n    },\n  });\n  return response.data;\n};\n\n// New function to get tickets without date filtering for debugging\nexport const getAllTicketsRaw = async (): Promise<any> => {\n  console.log('Fetching all tickets raw for debugging');\n  const debugInfo: any = {\n    requestInfo: {},\n    responseInfo: {},\n    error: null,\n    attempts: []\n  };\n  \n  try {\n    // Get auth token info\n    const token = localStorage.getItem('token');\n    debugInfo.requestInfo.auth = {\n      hasToken: !!token,\n      tokenLength: token ? token.length : 0,\n      tokenStart: token ? token.substring(0, 10) + '...' : 'none'\n    };\n    \n    // Try multiple variations of API calls to diagnose the issue\n    \n    // Attempt 1: Basic call without params\n    console.log('DEBUG attempt 1: Basic call without params');\n    debugInfo.attempts.push({ \n      name: 'Basic Call', \n      url: '/tickets',\n      params: {},\n      startTime: new Date().toISOString()\n    });\n    \n    let response = await api.get('/tickets');\n    \n    debugInfo.attempts[0].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[0].endTime = new Date().toISOString();\n    \n    // Attempt 2: With pagination params only\n    console.log('DEBUG attempt 2: With pagination params only');\n    const params = {\n      page: '1',\n      limit: '100'\n    };\n    \n    debugInfo.attempts.push({ \n      name: 'Pagination Only', \n      url: '/tickets',\n      params,\n      startTime: new Date().toISOString()\n    });\n    \n    response = await api.get('/tickets', { params });\n    \n    debugInfo.attempts[1].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[1].endTime = new Date().toISOString();\n    \n    // Attempt 3: With modified date range (all time)\n    console.log('DEBUG attempt 3: With all-time date range');\n    const dateParams = {\n      page: '1',\n      limit: '100',\n      startDate: '2020-01-01',\n      endDate: new Date().toISOString()\n    };\n    \n    debugInfo.attempts.push({ \n      name: 'All-Time Date Range', \n      url: '/tickets',\n      params: dateParams,\n      startTime: new Date().toISOString()\n    });\n    \n    response = await api.get('/tickets', { params: dateParams });\n    \n    debugInfo.attempts[2].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[2].endTime = new Date().toISOString();\n    \n    // Return the combined debug info\n    return {\n      success: true,\n      debugInfo,\n      mainResponse: response.data\n    };\n  } catch (error: any) {\n    console.error('Error in raw ticket fetch:', error);\n    debugInfo.error = {\n      message: error.message,\n      stack: error.stack,\n      response: error.response ? {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data\n      } : null\n    };\n    return { \n      success: false,\n      error: error.message,\n      debugInfo\n    };\n  }\n};\n\nexport const getTickets = async (\n  status?: TicketStatus,\n  page = 1,\n  limit = 10,\n  dateRange?: { startDate: Date; endDate: Date }\n) => {\n  try {\n    // Build query parameters\n    const params: Record<string, string> = {\n      page: page.toString(),\n      limit: limit.toString(),\n    };\n\n    if (status) {\n      params.status = status;\n    }\n\n    // Add date filter parameters if provided\n    if (dateRange) {\n      // Format dates as ISO strings and extract just the date part for consistency\n      params.startDate = dateRange.startDate.toISOString().split('T')[0];\n      \n      // For end date, ensure we're capturing the full day by setting time to end of day\n      const endDate = new Date(dateRange.endDate);\n      endDate.setHours(23, 59, 59, 999);\n      params.endDate = endDate.toISOString();\n      \n      console.log('API call with date range:', { \n        startDate: params.startDate, \n        endDate: params.endDate \n      });\n    } else {\n      console.log('API call with no date range provided');\n    }\n\n    const queryString = new URLSearchParams(params).toString();\n    \n    console.log(`Fetching tickets with params: ${queryString}`);\n    const response = await api.get(`/tickets?${queryString}`);\n    \n    // Add more detailed logging\n    console.log('API response type:', typeof response.data);\n    console.log('API response keys:', Object.keys(response.data || {}));\n    \n    // Check if response has the expected structure\n    if (response.data && response.data.tickets && Array.isArray(response.data.tickets)) {\n      console.log(`Found ${response.data.tickets.length} tickets in response`);\n      return response.data;\n    } \n    \n    // Handle case where response is directly an array of tickets\n    if (Array.isArray(response.data)) {\n      console.log(`Response is an array with ${response.data.length} tickets`);\n      return {\n        tickets: response.data,\n        pagination: {\n          page,\n          limit,\n          total: response.data.length,\n          totalPages: Math.ceil(response.data.length / limit),\n        }\n      };\n    }\n    \n    // Handle empty or unexpected response\n    console.warn('Unexpected response format:', response.data);\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      }\n    };\n  } catch (error: any) {\n    console.error('Error fetching tickets:', error);\n    console.error('Error details:', error.response?.data || error.message);\n    \n    // Return empty data structure instead of throwing\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      },\n      error: error.message\n    };\n  }\n};\n\nexport const updateTicketStatus = async (ticketId: string, status: string): Promise<Ticket> => {\n  const response = await api.put<Ticket>(`/tickets/${ticketId}`, { status });\n  return response.data;\n};\n\nexport const updateTicket = async (ticketId: string, updateData: Partial<Ticket>): Promise<Ticket> => {\n  const formData = new FormData();\n  \n  // Add basic ticket data if provided\n  if (updateData.title) formData.append('title', updateData.title);\n  if (updateData.description) formData.append('description', updateData.description);\n  if (updateData.status) formData.append('status', updateData.status);\n  if (updateData.department) formData.append('department', updateData.department);\n  if (updateData.chemicalConfig) formData.append('chemicalConfig', JSON.stringify(updateData.chemicalConfig));\n  \n  // Add new files if they exist\n  if (updateData.attachments && Array.isArray(updateData.attachments)) {\n    updateData.attachments.forEach(file => {\n      if (file instanceof File) {\n        formData.append('files', file);\n      }\n    });\n  }\n\n  const response = await api.put<Ticket>(`/tickets/${ticketId}`, formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data',\n    },\n  });\n  return response.data;\n};\n\nexport default api; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}