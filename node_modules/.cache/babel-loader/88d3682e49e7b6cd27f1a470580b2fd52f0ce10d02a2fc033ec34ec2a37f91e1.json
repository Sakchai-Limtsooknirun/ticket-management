{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// Add a simple ping function to check API connectivity\nexport const checkApiConnection = async () => {\n  var _localStorage$getItem;\n  console.log('Checking API connectivity');\n  const connectionInfo = {\n    apiBaseUrl: API_BASE_URL,\n    checks: [],\n    systemInfo: {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      connectionType: navigator.connection ? navigator.connection.effectiveType : 'unknown'\n    },\n    auth: {\n      hasToken: !!localStorage.getItem('token'),\n      tokenLength: ((_localStorage$getItem = localStorage.getItem('token')) === null || _localStorage$getItem === void 0 ? void 0 : _localStorage$getItem.length) || 0\n    },\n    startTime: new Date().toISOString()\n  };\n  try {\n    // Check 1: Simple connectivity check - OPTIONS request\n    connectionInfo.checks.push({\n      name: 'Basic OPTIONS Request',\n      endpoint: '/',\n      method: 'OPTIONS',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const optionsResponse = await axios.options(`${API_BASE_URL}/`);\n      connectionInfo.checks[0].status = 'success';\n      connectionInfo.checks[0].statusCode = optionsResponse.status;\n      connectionInfo.checks[0].headers = optionsResponse.headers;\n    } catch (error) {\n      connectionInfo.checks[0].status = 'error';\n      connectionInfo.checks[0].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[0].endTime = new Date().toISOString();\n\n    // Check 2: Health check or root endpoint\n    connectionInfo.checks.push({\n      name: 'API Root',\n      endpoint: '/',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const rootResponse = await axios.get(`${API_BASE_URL}/`);\n      connectionInfo.checks[1].status = 'success';\n      connectionInfo.checks[1].statusCode = rootResponse.status;\n      connectionInfo.checks[1].data = rootResponse.data;\n    } catch (error) {\n      connectionInfo.checks[1].status = 'error';\n      connectionInfo.checks[1].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[1].endTime = new Date().toISOString();\n\n    // Check 3: Authenticated endpoint\n    connectionInfo.checks.push({\n      name: 'Authenticated Request',\n      endpoint: '/tickets?limit=1',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const authResponse = await api.get('/tickets?limit=1');\n      connectionInfo.checks[2].status = 'success';\n      connectionInfo.checks[2].statusCode = authResponse.status;\n      connectionInfo.checks[2].dataType = typeof authResponse.data;\n      connectionInfo.checks[2].dataStructure = Array.isArray(authResponse.data) ? 'array' : typeof authResponse.data;\n    } catch (error) {\n      connectionInfo.checks[2].status = 'error';\n      connectionInfo.checks[2].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[2].endTime = new Date().toISOString();\n\n    // Check 4: Try the auth endpoint without credentials\n    connectionInfo.checks.push({\n      name: 'Auth Endpoint',\n      endpoint: '/auth/status',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      // Use axios directly to avoid sending auth token\n      const authStatusResponse = await axios.get(`${API_BASE_URL}/auth/status`);\n      connectionInfo.checks[3].status = 'success';\n      connectionInfo.checks[3].statusCode = authStatusResponse.status;\n      connectionInfo.checks[3].data = authStatusResponse.data;\n    } catch (error) {\n      // Even a 401 means the server is running\n      if (error.response) {\n        connectionInfo.checks[3].status = 'partial';\n        connectionInfo.checks[3].message = 'Server responded with error, but is reachable';\n        connectionInfo.checks[3].statusCode = error.response.status;\n      } else {\n        connectionInfo.checks[3].status = 'error';\n        connectionInfo.checks[3].error = {\n          message: error.message,\n          code: error.code\n        };\n      }\n    }\n    connectionInfo.checks[3].endTime = new Date().toISOString();\n\n    // Check if server appears to be running\n    const serverRunning = connectionInfo.checks.some(check => check.status === 'success' || check.status === 'partial');\n\n    // Check if auth appears to be working\n    const authWorking = connectionInfo.checks[2].status === 'success';\n\n    // Add summary\n    connectionInfo.summary = {\n      serverRunning,\n      authWorking,\n      completedChecks: connectionInfo.checks.length,\n      successfulChecks: connectionInfo.checks.filter(c => c.status === 'success').length\n    };\n    connectionInfo.endTime = new Date().toISOString();\n    connectionInfo.overallStatus = serverRunning ? 'server_reachable' : 'server_unreachable';\n    if (serverRunning && !authWorking) {\n      connectionInfo.overallStatus = 'auth_issue';\n    }\n    return connectionInfo;\n  } catch (error) {\n    connectionInfo.endTime = new Date().toISOString();\n    connectionInfo.overallStatus = 'check_failed';\n    connectionInfo.error = {\n      message: error.message,\n      stack: error.stack\n    };\n    return connectionInfo;\n  }\n};\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true\n});\n\n// Add token to requests if it exists\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem('token');\n  if (token && config.headers) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\nexport const login = async (username, password) => {\n  const response = await api.post('/auth/login', {\n    username,\n    password\n  });\n  return response.data;\n};\nexport const createTicket = async ticketData => {\n  const formData = new FormData();\n\n  // Add ticket data\n  formData.append('title', ticketData.title);\n  formData.append('description', ticketData.description);\n  formData.append('requesterId', ticketData.requesterId);\n  formData.append('department', ticketData.department);\n  formData.append('chemicalConfig', JSON.stringify(ticketData.chemicalConfig));\n\n  // Add files if they exist\n  if (ticketData.attachments && ticketData.attachments instanceof FileList) {\n    Array.from(ticketData.attachments).forEach(file => {\n      formData.append('files', file);\n    });\n  }\n  const response = await api.post('/tickets', formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    }\n  });\n  return response.data;\n};\n\n// New function to get tickets without date filtering for debugging\nexport const getAllTicketsRaw = async () => {\n  console.log('Fetching all tickets raw for debugging');\n  const debugInfo = {\n    requestInfo: {},\n    responseInfo: {},\n    error: null,\n    attempts: []\n  };\n  try {\n    // Get auth token info\n    const token = localStorage.getItem('token');\n    debugInfo.requestInfo.auth = {\n      hasToken: !!token,\n      tokenLength: token ? token.length : 0,\n      tokenStart: token ? token.substring(0, 10) + '...' : 'none'\n    };\n\n    // Try multiple variations of API calls to diagnose the issue\n\n    // Attempt 1: Basic call without params\n    console.log('DEBUG attempt 1: Basic call without params');\n    debugInfo.attempts.push({\n      name: 'Basic Call',\n      url: '/tickets',\n      params: {},\n      startTime: new Date().toISOString()\n    });\n    let response = await api.get('/tickets');\n    debugInfo.attempts[0].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[0].endTime = new Date().toISOString();\n\n    // Attempt 2: With pagination params only\n    console.log('DEBUG attempt 2: With pagination params only');\n    const params = {\n      page: '1',\n      limit: '100'\n    };\n    debugInfo.attempts.push({\n      name: 'Pagination Only',\n      url: '/tickets',\n      params,\n      startTime: new Date().toISOString()\n    });\n    response = await api.get('/tickets', {\n      params\n    });\n    debugInfo.attempts[1].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[1].endTime = new Date().toISOString();\n\n    // Attempt 3: With modified date range (all time)\n    console.log('DEBUG attempt 3: With all-time date range');\n    const dateParams = {\n      page: '1',\n      limit: '100',\n      startDate: '2020-01-01',\n      endDate: new Date().toISOString()\n    };\n    debugInfo.attempts.push({\n      name: 'All-Time Date Range',\n      url: '/tickets',\n      params: dateParams,\n      startTime: new Date().toISOString()\n    });\n    response = await api.get('/tickets', {\n      params: dateParams\n    });\n    debugInfo.attempts[2].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[2].endTime = new Date().toISOString();\n\n    // Return the combined debug info\n    return {\n      success: true,\n      debugInfo,\n      mainResponse: response.data\n    };\n  } catch (error) {\n    console.error('Error in raw ticket fetch:', error);\n    debugInfo.error = {\n      message: error.message,\n      stack: error.stack,\n      response: error.response ? {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data\n      } : null\n    };\n    return {\n      success: false,\n      error: error.message,\n      debugInfo\n    };\n  }\n};\nexport const getTickets = async (status, page = 1, limit = 10, dateRange) => {\n  try {\n    // Build query parameters\n    const params = {\n      page: page.toString(),\n      limit: limit.toString()\n    };\n    if (status) {\n      params.status = status;\n    }\n\n    // Add date filter parameters if provided\n    if (dateRange) {\n      // Format dates as ISO strings and extract just the date part for consistency\n      params.startDate = dateRange.startDate.toISOString().split('T')[0];\n\n      // For end date, ensure we're capturing the full day by setting time to end of day\n      const endDate = new Date(dateRange.endDate);\n      endDate.setHours(23, 59, 59, 999);\n      params.endDate = endDate.toISOString();\n      console.log('API call with date range:', {\n        startDate: params.startDate,\n        endDate: params.endDate\n      });\n    } else {\n      console.log('API call with no date range provided');\n    }\n    const queryString = new URLSearchParams(params).toString();\n    console.log(`Fetching tickets with params: ${queryString}`);\n    const response = await api.get(`/tickets?${queryString}`);\n\n    // Add more detailed logging\n    console.log('API response type:', typeof response.data);\n    console.log('API response keys:', Object.keys(response.data || {}));\n\n    // Check if response has the expected structure\n    if (response.data && response.data.tickets && Array.isArray(response.data.tickets)) {\n      console.log(`Found ${response.data.tickets.length} tickets in response`);\n      return response.data;\n    }\n\n    // Handle case where response is directly an array of tickets\n    if (Array.isArray(response.data)) {\n      console.log(`Response is an array with ${response.data.length} tickets`);\n      return {\n        tickets: response.data,\n        pagination: {\n          page,\n          limit,\n          total: response.data.length,\n          totalPages: Math.ceil(response.data.length / limit)\n        }\n      };\n    }\n\n    // Handle empty or unexpected response\n    console.warn('Unexpected response format:', response.data);\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      }\n    };\n  } catch (error) {\n    var _error$response;\n    console.error('Error fetching tickets:', error);\n    console.error('Error details:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n\n    // Return empty data structure instead of throwing\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      },\n      error: error.message\n    };\n  }\n};\nexport const updateTicketStatus = async (ticketId, status) => {\n  const response = await api.put(`/tickets/${ticketId}`, {\n    status\n  });\n  return response.data;\n};\nexport const updateTicket = async (ticketId, updateData) => {\n  const formData = new FormData();\n\n  // Add basic ticket data if provided\n  if (updateData.title) formData.append('title', updateData.title);\n  if (updateData.description) formData.append('description', updateData.description);\n  if (updateData.status) formData.append('status', updateData.status);\n  if (updateData.department) formData.append('department', updateData.department);\n  if (updateData.chemicalConfig) formData.append('chemicalConfig', JSON.stringify(updateData.chemicalConfig));\n\n  // Add new files if they exist\n  if (updateData.attachments && Array.isArray(updateData.attachments)) {\n    updateData.attachments.forEach(file => {\n      if (file instanceof File) {\n        formData.append('files', file);\n      }\n    });\n  }\n  const response = await api.put(`/tickets/${ticketId}`, formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    }\n  });\n  return response.data;\n};\nexport default api;","map":{"version":3,"names":["axios","API_BASE_URL","checkApiConnection","_localStorage$getItem","console","log","connectionInfo","apiBaseUrl","checks","systemInfo","userAgent","navigator","platform","language","connectionType","connection","effectiveType","auth","hasToken","localStorage","getItem","tokenLength","length","startTime","Date","toISOString","push","name","endpoint","method","status","optionsResponse","options","statusCode","headers","error","message","code","endTime","rootResponse","get","data","response","authResponse","api","dataType","dataStructure","Array","isArray","authStatusResponse","serverRunning","some","check","authWorking","summary","completedChecks","successfulChecks","filter","c","overallStatus","stack","create","baseURL","withCredentials","interceptors","request","use","config","token","Authorization","login","username","password","post","createTicket","ticketData","formData","FormData","append","title","description","requesterId","department","JSON","stringify","chemicalConfig","attachments","FileList","from","forEach","file","getAllTicketsRaw","debugInfo","requestInfo","responseInfo","attempts","tokenStart","substring","url","params","statusText","page","limit","dateParams","startDate","endDate","success","mainResponse","getTickets","dateRange","toString","split","setHours","queryString","URLSearchParams","Object","keys","tickets","pagination","total","totalPages","Math","ceil","warn","_error$response","updateTicketStatus","ticketId","put","updateTicket","updateData","File"],"sources":["/Users/a667227/Desktop/Work/ticket-management/src/services/api.ts"],"sourcesContent":["import axios, { InternalAxiosRequestConfig } from 'axios';\nimport { Ticket, TicketStatus } from '../types/system';\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// Add a simple ping function to check API connectivity\nexport const checkApiConnection = async (): Promise<any> => {\n  console.log('Checking API connectivity');\n  const connectionInfo: any = {\n    apiBaseUrl: API_BASE_URL,\n    checks: [],\n    systemInfo: {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      connectionType: (navigator as any).connection ? \n        (navigator as any).connection.effectiveType : 'unknown'\n    },\n    auth: {\n      hasToken: !!localStorage.getItem('token'),\n      tokenLength: localStorage.getItem('token')?.length || 0\n    },\n    startTime: new Date().toISOString()\n  };\n  \n  try {\n    // Check 1: Simple connectivity check - OPTIONS request\n    connectionInfo.checks.push({\n      name: 'Basic OPTIONS Request',\n      endpoint: '/',\n      method: 'OPTIONS',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const optionsResponse = await axios.options(`${API_BASE_URL}/`);\n      connectionInfo.checks[0].status = 'success';\n      connectionInfo.checks[0].statusCode = optionsResponse.status;\n      connectionInfo.checks[0].headers = optionsResponse.headers;\n    } catch (error: any) {\n      connectionInfo.checks[0].status = 'error';\n      connectionInfo.checks[0].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[0].endTime = new Date().toISOString();\n    \n    // Check 2: Health check or root endpoint\n    connectionInfo.checks.push({\n      name: 'API Root',\n      endpoint: '/',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const rootResponse = await axios.get(`${API_BASE_URL}/`);\n      connectionInfo.checks[1].status = 'success';\n      connectionInfo.checks[1].statusCode = rootResponse.status;\n      connectionInfo.checks[1].data = rootResponse.data;\n    } catch (error: any) {\n      connectionInfo.checks[1].status = 'error';\n      connectionInfo.checks[1].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[1].endTime = new Date().toISOString();\n    \n    // Check 3: Authenticated endpoint\n    connectionInfo.checks.push({\n      name: 'Authenticated Request',\n      endpoint: '/tickets?limit=1',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const authResponse = await api.get('/tickets?limit=1');\n      connectionInfo.checks[2].status = 'success';\n      connectionInfo.checks[2].statusCode = authResponse.status;\n      connectionInfo.checks[2].dataType = typeof authResponse.data;\n      connectionInfo.checks[2].dataStructure = Array.isArray(authResponse.data) ? \n        'array' : typeof authResponse.data;\n    } catch (error: any) {\n      connectionInfo.checks[2].status = 'error';\n      connectionInfo.checks[2].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[2].endTime = new Date().toISOString();\n    \n    // Check 4: Try the auth endpoint without credentials\n    connectionInfo.checks.push({\n      name: 'Auth Endpoint',\n      endpoint: '/auth/status',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      // Use axios directly to avoid sending auth token\n      const authStatusResponse = await axios.get(`${API_BASE_URL}/auth/status`);\n      connectionInfo.checks[3].status = 'success';\n      connectionInfo.checks[3].statusCode = authStatusResponse.status;\n      connectionInfo.checks[3].data = authStatusResponse.data;\n    } catch (error: any) {\n      // Even a 401 means the server is running\n      if (error.response) {\n        connectionInfo.checks[3].status = 'partial';\n        connectionInfo.checks[3].message = 'Server responded with error, but is reachable';\n        connectionInfo.checks[3].statusCode = error.response.status;\n      } else {\n        connectionInfo.checks[3].status = 'error';\n        connectionInfo.checks[3].error = {\n          message: error.message,\n          code: error.code\n        };\n      }\n    }\n    connectionInfo.checks[3].endTime = new Date().toISOString();\n    \n    // Check if server appears to be running\n    const serverRunning = connectionInfo.checks.some(\n      (check: any) => check.status === 'success' || check.status === 'partial'\n    );\n    \n    // Check if auth appears to be working\n    const authWorking = connectionInfo.checks[2].status === 'success';\n    \n    // Add summary\n    connectionInfo.summary = {\n      serverRunning,\n      authWorking,\n      completedChecks: connectionInfo.checks.length,\n      successfulChecks: connectionInfo.checks.filter((c: any) => c.status === 'success').length\n    };\n    \n    connectionInfo.endTime = new Date().toISOString();\n    connectionInfo.overallStatus = serverRunning ? 'server_reachable' : 'server_unreachable';\n    \n    if (serverRunning && !authWorking) {\n      connectionInfo.overallStatus = 'auth_issue';\n    }\n    \n    return connectionInfo;\n  } catch (error: any) {\n    connectionInfo.endTime = new Date().toISOString();\n    connectionInfo.overallStatus = 'check_failed';\n    connectionInfo.error = {\n      message: error.message,\n      stack: error.stack\n    };\n    return connectionInfo;\n  }\n};\n\nexport interface LoginResponse {\n  token: string;\n  user: {\n    id: string;\n    username: string;\n    email: string;\n    fullName: string;\n    role: string;\n    department: string;\n  };\n}\n\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  withCredentials: true\n});\n\n// Add token to requests if it exists\napi.interceptors.request.use((config: InternalAxiosRequestConfig) => {\n  const token = localStorage.getItem('token');\n  if (token && config.headers) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\n\nexport const login = async (username: string, password: string): Promise<LoginResponse> => {\n  const response = await api.post<LoginResponse>('/auth/login', { username, password });\n  return response.data;\n};\n\nexport const createTicket = async (ticketData: Omit<Ticket, 'id' | 'status' | 'createdAt' | 'updatedAt'>): Promise<Ticket> => {\n  const formData = new FormData();\n  \n  // Add ticket data\n  formData.append('title', ticketData.title);\n  formData.append('description', ticketData.description);\n  formData.append('requesterId', ticketData.requesterId);\n  formData.append('department', ticketData.department);\n  formData.append('chemicalConfig', JSON.stringify(ticketData.chemicalConfig));\n  \n  // Add files if they exist\n  if (ticketData.attachments && ticketData.attachments instanceof FileList) {\n    Array.from(ticketData.attachments).forEach(file => {\n      formData.append('files', file);\n    });\n  }\n\n  const response = await api.post<Ticket>('/tickets', formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data',\n    },\n  });\n  return response.data;\n};\n\n// New function to get tickets without date filtering for debugging\nexport const getAllTicketsRaw = async (): Promise<any> => {\n  console.log('Fetching all tickets raw for debugging');\n  const debugInfo: any = {\n    requestInfo: {},\n    responseInfo: {},\n    error: null,\n    attempts: []\n  };\n  \n  try {\n    // Get auth token info\n    const token = localStorage.getItem('token');\n    debugInfo.requestInfo.auth = {\n      hasToken: !!token,\n      tokenLength: token ? token.length : 0,\n      tokenStart: token ? token.substring(0, 10) + '...' : 'none'\n    };\n    \n    // Try multiple variations of API calls to diagnose the issue\n    \n    // Attempt 1: Basic call without params\n    console.log('DEBUG attempt 1: Basic call without params');\n    debugInfo.attempts.push({ \n      name: 'Basic Call', \n      url: '/tickets',\n      params: {},\n      startTime: new Date().toISOString()\n    });\n    \n    let response = await api.get('/tickets');\n    \n    debugInfo.attempts[0].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[0].endTime = new Date().toISOString();\n    \n    // Attempt 2: With pagination params only\n    console.log('DEBUG attempt 2: With pagination params only');\n    const params = {\n      page: '1',\n      limit: '100'\n    };\n    \n    debugInfo.attempts.push({ \n      name: 'Pagination Only', \n      url: '/tickets',\n      params,\n      startTime: new Date().toISOString()\n    });\n    \n    response = await api.get('/tickets', { params });\n    \n    debugInfo.attempts[1].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[1].endTime = new Date().toISOString();\n    \n    // Attempt 3: With modified date range (all time)\n    console.log('DEBUG attempt 3: With all-time date range');\n    const dateParams = {\n      page: '1',\n      limit: '100',\n      startDate: '2020-01-01',\n      endDate: new Date().toISOString()\n    };\n    \n    debugInfo.attempts.push({ \n      name: 'All-Time Date Range', \n      url: '/tickets',\n      params: dateParams,\n      startTime: new Date().toISOString()\n    });\n    \n    response = await api.get('/tickets', { params: dateParams });\n    \n    debugInfo.attempts[2].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[2].endTime = new Date().toISOString();\n    \n    // Return the combined debug info\n    return {\n      success: true,\n      debugInfo,\n      mainResponse: response.data\n    };\n  } catch (error: any) {\n    console.error('Error in raw ticket fetch:', error);\n    debugInfo.error = {\n      message: error.message,\n      stack: error.stack,\n      response: error.response ? {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data\n      } : null\n    };\n    return { \n      success: false,\n      error: error.message,\n      debugInfo\n    };\n  }\n};\n\nexport const getTickets = async (\n  status?: TicketStatus,\n  page = 1,\n  limit = 10,\n  dateRange?: { startDate: Date; endDate: Date }\n) => {\n  try {\n    // Build query parameters\n    const params: Record<string, string> = {\n      page: page.toString(),\n      limit: limit.toString(),\n    };\n\n    if (status) {\n      params.status = status;\n    }\n\n    // Add date filter parameters if provided\n    if (dateRange) {\n      // Format dates as ISO strings and extract just the date part for consistency\n      params.startDate = dateRange.startDate.toISOString().split('T')[0];\n      \n      // For end date, ensure we're capturing the full day by setting time to end of day\n      const endDate = new Date(dateRange.endDate);\n      endDate.setHours(23, 59, 59, 999);\n      params.endDate = endDate.toISOString();\n      \n      console.log('API call with date range:', { \n        startDate: params.startDate, \n        endDate: params.endDate \n      });\n    } else {\n      console.log('API call with no date range provided');\n    }\n\n    const queryString = new URLSearchParams(params).toString();\n    \n    console.log(`Fetching tickets with params: ${queryString}`);\n    const response = await api.get(`/tickets?${queryString}`);\n    \n    // Add more detailed logging\n    console.log('API response type:', typeof response.data);\n    console.log('API response keys:', Object.keys(response.data || {}));\n    \n    // Check if response has the expected structure\n    if (response.data && response.data.tickets && Array.isArray(response.data.tickets)) {\n      console.log(`Found ${response.data.tickets.length} tickets in response`);\n      return response.data;\n    } \n    \n    // Handle case where response is directly an array of tickets\n    if (Array.isArray(response.data)) {\n      console.log(`Response is an array with ${response.data.length} tickets`);\n      return {\n        tickets: response.data,\n        pagination: {\n          page,\n          limit,\n          total: response.data.length,\n          totalPages: Math.ceil(response.data.length / limit),\n        }\n      };\n    }\n    \n    // Handle empty or unexpected response\n    console.warn('Unexpected response format:', response.data);\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      }\n    };\n  } catch (error: any) {\n    console.error('Error fetching tickets:', error);\n    console.error('Error details:', error.response?.data || error.message);\n    \n    // Return empty data structure instead of throwing\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      },\n      error: error.message\n    };\n  }\n};\n\nexport const updateTicketStatus = async (ticketId: string, status: string): Promise<Ticket> => {\n  const response = await api.put<Ticket>(`/tickets/${ticketId}`, { status });\n  return response.data;\n};\n\nexport const updateTicket = async (ticketId: string, updateData: Partial<Ticket>): Promise<Ticket> => {\n  const formData = new FormData();\n  \n  // Add basic ticket data if provided\n  if (updateData.title) formData.append('title', updateData.title);\n  if (updateData.description) formData.append('description', updateData.description);\n  if (updateData.status) formData.append('status', updateData.status);\n  if (updateData.department) formData.append('department', updateData.department);\n  if (updateData.chemicalConfig) formData.append('chemicalConfig', JSON.stringify(updateData.chemicalConfig));\n  \n  // Add new files if they exist\n  if (updateData.attachments && Array.isArray(updateData.attachments)) {\n    updateData.attachments.forEach(file => {\n      if (file instanceof File) {\n        formData.append('files', file);\n      }\n    });\n  }\n\n  const response = await api.put<Ticket>(`/tickets/${ticketId}`, formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data',\n    },\n  });\n  return response.data;\n};\n\nexport default api; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}