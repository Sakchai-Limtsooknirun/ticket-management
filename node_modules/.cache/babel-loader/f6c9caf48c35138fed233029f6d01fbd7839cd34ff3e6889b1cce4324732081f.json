{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// Add a simple ping function to check API connectivity\nexport const checkApiConnection = async () => {\n  var _localStorage$getItem;\n  console.log('Checking API connectivity');\n  const connectionInfo = {\n    apiBaseUrl: API_BASE_URL,\n    checks: [],\n    systemInfo: {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      connectionType: navigator.connection ? navigator.connection.effectiveType : 'unknown'\n    },\n    auth: {\n      hasToken: !!localStorage.getItem('token'),\n      tokenLength: ((_localStorage$getItem = localStorage.getItem('token')) === null || _localStorage$getItem === void 0 ? void 0 : _localStorage$getItem.length) || 0\n    },\n    startTime: new Date().toISOString()\n  };\n  try {\n    // Check 1: Simple connectivity check - OPTIONS request\n    connectionInfo.checks.push({\n      name: 'Basic OPTIONS Request',\n      endpoint: '/',\n      method: 'OPTIONS',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const optionsResponse = await axios.options(`${API_BASE_URL}/`);\n      connectionInfo.checks[0].status = 'success';\n      connectionInfo.checks[0].statusCode = optionsResponse.status;\n      connectionInfo.checks[0].headers = optionsResponse.headers;\n    } catch (error) {\n      connectionInfo.checks[0].status = 'error';\n      connectionInfo.checks[0].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[0].endTime = new Date().toISOString();\n\n    // Check 2: Try the auth login endpoint\n    connectionInfo.checks.push({\n      name: 'Auth Login Endpoint',\n      endpoint: '/auth/login',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      // Just check if the endpoint exists without sending credentials\n      const authEndpointResponse = await axios.get(`${API_BASE_URL}/auth/login`, {\n        validateStatus: status => status < 500 // Allow 4xx responses\n      });\n\n      // Even 401 or 405 means the endpoint exists\n      connectionInfo.checks[1].status = 'success';\n      connectionInfo.checks[1].statusCode = authEndpointResponse.status;\n      connectionInfo.checks[1].message = 'Auth endpoint exists (returned ' + authEndpointResponse.status + ')';\n    } catch (error) {\n      connectionInfo.checks[1].status = 'error';\n      connectionInfo.checks[1].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[1].endTime = new Date().toISOString();\n\n    // Check 3: Try the tickets endpoint\n    connectionInfo.checks.push({\n      name: 'Tickets Endpoint',\n      endpoint: '/tickets',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const ticketsResponse = await axios.get(`${API_BASE_URL}/tickets`, {\n        validateStatus: status => status < 500,\n        // Allow 4xx responses\n        headers: {\n          // Add token if available\n          ...(localStorage.getItem('token') ? {\n            Authorization: `Bearer ${localStorage.getItem('token')}`\n          } : {})\n        }\n      });\n\n      // Even 401 is OK - it means the endpoint exists\n      const endpointExists = ticketsResponse.status !== 404;\n      connectionInfo.checks[2].status = endpointExists ? 'success' : 'error';\n      connectionInfo.checks[2].statusCode = ticketsResponse.status;\n      connectionInfo.checks[2].message = `Tickets endpoint ${endpointExists ? 'exists' : 'does not exist'} (${ticketsResponse.status})`;\n      if (ticketsResponse.status === 200) {\n        connectionInfo.checks[2].dataType = typeof ticketsResponse.data;\n        connectionInfo.checks[2].dataStructure = Array.isArray(ticketsResponse.data) ? 'array' : typeof ticketsResponse.data;\n      }\n    } catch (error) {\n      connectionInfo.checks[2].status = 'error';\n      connectionInfo.checks[2].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[2].endTime = new Date().toISOString();\n\n    // Check 4: Try the root API endpoint\n    connectionInfo.checks.push({\n      name: 'Root API Check',\n      endpoint: '/',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    try {\n      const rootResponse = await axios.get(`${API_BASE_URL}`, {\n        validateStatus: status => status < 500 // Allow 4xx responses\n      });\n      connectionInfo.checks[3].status = 'success';\n      connectionInfo.checks[3].statusCode = rootResponse.status;\n      connectionInfo.checks[3].message = `Root API endpoint response: ${rootResponse.status}`;\n    } catch (error) {\n      connectionInfo.checks[3].status = 'error';\n      connectionInfo.checks[3].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[3].endTime = new Date().toISOString();\n\n    // Check if server appears to be running at all\n    const anySuccessfulCheck = connectionInfo.checks.some(check => check.status === 'success');\n    const anyNon404Response = connectionInfo.checks.some(check => check.statusCode && check.statusCode !== 404 && check.statusCode !== 0);\n\n    // If we got any non-404 response, the server is probably running\n    // but might have incorrect routes\n    const serverRunning = anySuccessfulCheck || anyNon404Response;\n\n    // Check if auth appears to be properly configured\n    const authEndpointExists = connectionInfo.checks[1].status === 'success';\n\n    // Add summary\n    connectionInfo.summary = {\n      serverRunning,\n      authEndpointExists,\n      completedChecks: connectionInfo.checks.length,\n      successfulChecks: connectionInfo.checks.filter(c => c.status === 'success').length,\n      possibleIssues: []\n    };\n\n    // Add issue analysis\n    if (!serverRunning) {\n      connectionInfo.summary.possibleIssues.push('Server is not running or not accessible');\n    } else if (connectionInfo.checks.every(c => c.statusCode === 404)) {\n      connectionInfo.summary.possibleIssues.push('Server is running but all API routes return 404 - check API_BASE_URL and server routes');\n    }\n    if (authEndpointExists && connectionInfo.checks[1].statusCode === 404) {\n      connectionInfo.summary.possibleIssues.push('Auth endpoint not found - check backend routes configuration');\n    }\n    connectionInfo.endTime = new Date().toISOString();\n\n    // Determine overall status\n    if (!serverRunning) {\n      connectionInfo.overallStatus = 'server_unreachable';\n    } else if (connectionInfo.checks.every(c => c.statusCode === 404)) {\n      connectionInfo.overallStatus = 'wrong_api_base_url';\n    } else if (!authEndpointExists) {\n      connectionInfo.overallStatus = 'auth_endpoint_missing';\n    } else {\n      connectionInfo.overallStatus = 'server_reachable';\n    }\n    return connectionInfo;\n  } catch (error) {\n    connectionInfo.endTime = new Date().toISOString();\n    connectionInfo.overallStatus = 'check_failed';\n    connectionInfo.error = {\n      message: error.message,\n      stack: error.stack\n    };\n    return connectionInfo;\n  }\n};\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  withCredentials: true\n});\n\n// Add token to requests if it exists\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem('token');\n  if (token && config.headers) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\nexport const login = async (username, password) => {\n  const response = await api.post('/auth/login', {\n    username,\n    password\n  });\n  return response.data;\n};\nexport const createTicket = async ticketData => {\n  const formData = new FormData();\n\n  // Add ticket data\n  formData.append('title', ticketData.title);\n  formData.append('description', ticketData.description);\n  formData.append('requesterId', ticketData.requesterId);\n  formData.append('department', ticketData.department);\n  formData.append('chemicalConfig', JSON.stringify(ticketData.chemicalConfig));\n\n  // Add files if they exist\n  if (ticketData.attachments && ticketData.attachments instanceof FileList) {\n    Array.from(ticketData.attachments).forEach(file => {\n      formData.append('files', file);\n    });\n  }\n  const response = await api.post('/tickets', formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    }\n  });\n  return response.data;\n};\n\n// New function to get tickets without date filtering for debugging\nexport const getAllTicketsRaw = async () => {\n  console.log('Fetching all tickets raw for debugging');\n  const debugInfo = {\n    requestInfo: {},\n    responseInfo: {},\n    error: null,\n    attempts: []\n  };\n  try {\n    // Get auth token info\n    const token = localStorage.getItem('token');\n    debugInfo.requestInfo.auth = {\n      hasToken: !!token,\n      tokenLength: token ? token.length : 0,\n      tokenStart: token ? token.substring(0, 10) + '...' : 'none'\n    };\n\n    // Try multiple variations of API calls to diagnose the issue\n\n    // Attempt 1: Basic call without params\n    console.log('DEBUG attempt 1: Basic call without params');\n    debugInfo.attempts.push({\n      name: 'Basic Call',\n      url: '/tickets',\n      params: {},\n      startTime: new Date().toISOString()\n    });\n    let response = await api.get('/tickets');\n    debugInfo.attempts[0].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[0].endTime = new Date().toISOString();\n\n    // Attempt 2: With pagination params only\n    console.log('DEBUG attempt 2: With pagination params only');\n    const params = {\n      page: '1',\n      limit: '100'\n    };\n    debugInfo.attempts.push({\n      name: 'Pagination Only',\n      url: '/tickets',\n      params,\n      startTime: new Date().toISOString()\n    });\n    response = await api.get('/tickets', {\n      params\n    });\n    debugInfo.attempts[1].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[1].endTime = new Date().toISOString();\n\n    // Attempt 3: With modified date range (all time)\n    console.log('DEBUG attempt 3: With all-time date range');\n    const dateParams = {\n      page: '1',\n      limit: '100',\n      startDate: '2020-01-01',\n      endDate: new Date().toISOString()\n    };\n    debugInfo.attempts.push({\n      name: 'All-Time Date Range',\n      url: '/tickets',\n      params: dateParams,\n      startTime: new Date().toISOString()\n    });\n    response = await api.get('/tickets', {\n      params: dateParams\n    });\n    debugInfo.attempts[2].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[2].endTime = new Date().toISOString();\n\n    // Return the combined debug info\n    return {\n      success: true,\n      debugInfo,\n      mainResponse: response.data\n    };\n  } catch (error) {\n    console.error('Error in raw ticket fetch:', error);\n    debugInfo.error = {\n      message: error.message,\n      stack: error.stack,\n      response: error.response ? {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data\n      } : null\n    };\n    return {\n      success: false,\n      error: error.message,\n      debugInfo\n    };\n  }\n};\nexport const getTickets = async (status, page = 1, limit = 10, dateRange) => {\n  try {\n    // Build query parameters\n    const params = {\n      page: page.toString(),\n      limit: limit.toString()\n    };\n    if (status) {\n      params.status = status;\n    }\n\n    // Add date filter parameters if provided\n    if (dateRange) {\n      // Format dates as ISO strings and extract just the date part for consistency\n      params.startDate = dateRange.startDate.toISOString().split('T')[0];\n\n      // For end date, ensure we're capturing the full day by setting time to end of day\n      const endDate = new Date(dateRange.endDate);\n      endDate.setHours(23, 59, 59, 999);\n      params.endDate = endDate.toISOString();\n      console.log('API call with date range:', {\n        startDate: params.startDate,\n        endDate: params.endDate\n      });\n    } else {\n      console.log('API call with no date range provided');\n    }\n    const queryString = new URLSearchParams(params).toString();\n    console.log(`Fetching tickets with params: ${queryString}`);\n    const response = await api.get(`/tickets?${queryString}`);\n\n    // Add more detailed logging\n    console.log('API response type:', typeof response.data);\n    console.log('API response keys:', Object.keys(response.data || {}));\n\n    // Check if response has the expected structure\n    if (response.data && response.data.tickets && Array.isArray(response.data.tickets)) {\n      console.log(`Found ${response.data.tickets.length} tickets in response`);\n      return response.data;\n    }\n\n    // Handle case where response is directly an array of tickets\n    if (Array.isArray(response.data)) {\n      console.log(`Response is an array with ${response.data.length} tickets`);\n      return {\n        tickets: response.data,\n        pagination: {\n          page,\n          limit,\n          total: response.data.length,\n          totalPages: Math.ceil(response.data.length / limit)\n        }\n      };\n    }\n\n    // Handle empty or unexpected response\n    console.warn('Unexpected response format:', response.data);\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      }\n    };\n  } catch (error) {\n    var _error$response;\n    console.error('Error fetching tickets:', error);\n    console.error('Error details:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n\n    // Return empty data structure instead of throwing\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      },\n      error: error.message\n    };\n  }\n};\nexport const updateTicketStatus = async (ticketId, status) => {\n  const response = await api.put(`/tickets/${ticketId}`, {\n    status\n  });\n  return response.data;\n};\nexport const updateTicket = async (ticketId, updateData) => {\n  const formData = new FormData();\n\n  // Add basic ticket data if provided\n  if (updateData.title) formData.append('title', updateData.title);\n  if (updateData.description) formData.append('description', updateData.description);\n  if (updateData.status) formData.append('status', updateData.status);\n  if (updateData.department) formData.append('department', updateData.department);\n  if (updateData.chemicalConfig) formData.append('chemicalConfig', JSON.stringify(updateData.chemicalConfig));\n\n  // Add new files if they exist\n  if (updateData.attachments && Array.isArray(updateData.attachments)) {\n    updateData.attachments.forEach(file => {\n      if (file instanceof File) {\n        formData.append('files', file);\n      }\n    });\n  }\n  const response = await api.put(`/tickets/${ticketId}`, formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    }\n  });\n  return response.data;\n};\nexport default api;","map":{"version":3,"names":["axios","API_BASE_URL","checkApiConnection","_localStorage$getItem","console","log","connectionInfo","apiBaseUrl","checks","systemInfo","userAgent","navigator","platform","language","connectionType","connection","effectiveType","auth","hasToken","localStorage","getItem","tokenLength","length","startTime","Date","toISOString","push","name","endpoint","method","status","optionsResponse","options","statusCode","headers","error","message","code","endTime","authEndpointResponse","get","validateStatus","response","data","ticketsResponse","Authorization","endpointExists","dataType","dataStructure","Array","isArray","rootResponse","anySuccessfulCheck","some","check","anyNon404Response","serverRunning","authEndpointExists","summary","completedChecks","successfulChecks","filter","c","possibleIssues","every","overallStatus","stack","api","create","baseURL","withCredentials","interceptors","request","use","config","token","login","username","password","post","createTicket","ticketData","formData","FormData","append","title","description","requesterId","department","JSON","stringify","chemicalConfig","attachments","FileList","from","forEach","file","getAllTicketsRaw","debugInfo","requestInfo","responseInfo","attempts","tokenStart","substring","url","params","statusText","page","limit","dateParams","startDate","endDate","success","mainResponse","getTickets","dateRange","toString","split","setHours","queryString","URLSearchParams","Object","keys","tickets","pagination","total","totalPages","Math","ceil","warn","_error$response","updateTicketStatus","ticketId","put","updateTicket","updateData","File"],"sources":["/Users/a667227/Desktop/Work/ticket-management/src/services/api.ts"],"sourcesContent":["import axios, { InternalAxiosRequestConfig } from 'axios';\nimport { Ticket, TicketStatus } from '../types/system';\n\nconst API_BASE_URL = 'http://localhost:5001/api';\n\n// Add a simple ping function to check API connectivity\nexport const checkApiConnection = async (): Promise<any> => {\n  console.log('Checking API connectivity');\n  const connectionInfo: any = {\n    apiBaseUrl: API_BASE_URL,\n    checks: [],\n    systemInfo: {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      connectionType: (navigator as any).connection ? \n        (navigator as any).connection.effectiveType : 'unknown'\n    },\n    auth: {\n      hasToken: !!localStorage.getItem('token'),\n      tokenLength: localStorage.getItem('token')?.length || 0\n    },\n    startTime: new Date().toISOString()\n  };\n  \n  try {\n    // Check 1: Simple connectivity check - OPTIONS request\n    connectionInfo.checks.push({\n      name: 'Basic OPTIONS Request',\n      endpoint: '/',\n      method: 'OPTIONS',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const optionsResponse = await axios.options(`${API_BASE_URL}/`);\n      connectionInfo.checks[0].status = 'success';\n      connectionInfo.checks[0].statusCode = optionsResponse.status;\n      connectionInfo.checks[0].headers = optionsResponse.headers;\n    } catch (error: any) {\n      connectionInfo.checks[0].status = 'error';\n      connectionInfo.checks[0].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[0].endTime = new Date().toISOString();\n    \n    // Check 2: Try the auth login endpoint\n    connectionInfo.checks.push({\n      name: 'Auth Login Endpoint',\n      endpoint: '/auth/login',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      // Just check if the endpoint exists without sending credentials\n      const authEndpointResponse = await axios.get(`${API_BASE_URL}/auth/login`, {\n        validateStatus: (status) => status < 500 // Allow 4xx responses\n      });\n      \n      // Even 401 or 405 means the endpoint exists\n      connectionInfo.checks[1].status = 'success';\n      connectionInfo.checks[1].statusCode = authEndpointResponse.status;\n      connectionInfo.checks[1].message = 'Auth endpoint exists (returned ' + authEndpointResponse.status + ')';\n    } catch (error: any) {\n      connectionInfo.checks[1].status = 'error';\n      connectionInfo.checks[1].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[1].endTime = new Date().toISOString();\n    \n    // Check 3: Try the tickets endpoint\n    connectionInfo.checks.push({\n      name: 'Tickets Endpoint',\n      endpoint: '/tickets',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const ticketsResponse = await axios.get(`${API_BASE_URL}/tickets`, {\n        validateStatus: (status) => status < 500, // Allow 4xx responses\n        headers: { \n          // Add token if available\n          ...(localStorage.getItem('token') \n            ? { Authorization: `Bearer ${localStorage.getItem('token')}` } \n            : {})\n        }\n      });\n      \n      // Even 401 is OK - it means the endpoint exists\n      const endpointExists = ticketsResponse.status !== 404;\n      connectionInfo.checks[2].status = endpointExists ? 'success' : 'error';\n      connectionInfo.checks[2].statusCode = ticketsResponse.status;\n      connectionInfo.checks[2].message = `Tickets endpoint ${endpointExists ? 'exists' : 'does not exist'} (${ticketsResponse.status})`;\n      \n      if (ticketsResponse.status === 200) {\n        connectionInfo.checks[2].dataType = typeof ticketsResponse.data;\n        connectionInfo.checks[2].dataStructure = Array.isArray(ticketsResponse.data) ? \n          'array' : typeof ticketsResponse.data;\n      }\n    } catch (error: any) {\n      connectionInfo.checks[2].status = 'error';\n      connectionInfo.checks[2].error = {\n        message: error.message,\n        code: error.code,\n        response: error.response ? {\n          status: error.response.status,\n          data: error.response.data\n        } : null\n      };\n    }\n    connectionInfo.checks[2].endTime = new Date().toISOString();\n    \n    // Check 4: Try the root API endpoint\n    connectionInfo.checks.push({\n      name: 'Root API Check',\n      endpoint: '/',\n      method: 'GET',\n      startTime: new Date().toISOString(),\n      status: 'pending'\n    });\n    \n    try {\n      const rootResponse = await axios.get(`${API_BASE_URL}`, {\n        validateStatus: (status) => status < 500 // Allow 4xx responses\n      });\n      \n      connectionInfo.checks[3].status = 'success';\n      connectionInfo.checks[3].statusCode = rootResponse.status;\n      connectionInfo.checks[3].message = `Root API endpoint response: ${rootResponse.status}`;\n    } catch (error: any) {\n      connectionInfo.checks[3].status = 'error';\n      connectionInfo.checks[3].error = {\n        message: error.message,\n        code: error.code\n      };\n    }\n    connectionInfo.checks[3].endTime = new Date().toISOString();\n    \n    // Check if server appears to be running at all\n    const anySuccessfulCheck = connectionInfo.checks.some(\n      (check: any) => check.status === 'success'\n    );\n    \n    const anyNon404Response = connectionInfo.checks.some(\n      (check: any) => \n        check.statusCode && \n        check.statusCode !== 404 && \n        check.statusCode !== 0\n    );\n    \n    // If we got any non-404 response, the server is probably running\n    // but might have incorrect routes\n    const serverRunning = anySuccessfulCheck || anyNon404Response;\n    \n    // Check if auth appears to be properly configured\n    const authEndpointExists = connectionInfo.checks[1].status === 'success';\n    \n    // Add summary\n    connectionInfo.summary = {\n      serverRunning,\n      authEndpointExists,\n      completedChecks: connectionInfo.checks.length,\n      successfulChecks: connectionInfo.checks.filter((c: any) => c.status === 'success').length,\n      possibleIssues: []\n    };\n    \n    // Add issue analysis\n    if (!serverRunning) {\n      connectionInfo.summary.possibleIssues.push('Server is not running or not accessible');\n    } else if (connectionInfo.checks.every(c => c.statusCode === 404)) {\n      connectionInfo.summary.possibleIssues.push('Server is running but all API routes return 404 - check API_BASE_URL and server routes');\n    }\n    \n    if (authEndpointExists && connectionInfo.checks[1].statusCode === 404) {\n      connectionInfo.summary.possibleIssues.push('Auth endpoint not found - check backend routes configuration');\n    }\n    \n    connectionInfo.endTime = new Date().toISOString();\n    \n    // Determine overall status\n    if (!serverRunning) {\n      connectionInfo.overallStatus = 'server_unreachable';\n    } else if (connectionInfo.checks.every(c => c.statusCode === 404)) {\n      connectionInfo.overallStatus = 'wrong_api_base_url';\n    } else if (!authEndpointExists) {\n      connectionInfo.overallStatus = 'auth_endpoint_missing';\n    } else {\n      connectionInfo.overallStatus = 'server_reachable';\n    }\n    \n    return connectionInfo;\n  } catch (error: any) {\n    connectionInfo.endTime = new Date().toISOString();\n    connectionInfo.overallStatus = 'check_failed';\n    connectionInfo.error = {\n      message: error.message,\n      stack: error.stack\n    };\n    return connectionInfo;\n  }\n};\n\nexport interface LoginResponse {\n  token: string;\n  user: {\n    id: string;\n    username: string;\n    email: string;\n    fullName: string;\n    role: string;\n    department: string;\n  };\n}\n\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  withCredentials: true\n});\n\n// Add token to requests if it exists\napi.interceptors.request.use((config: InternalAxiosRequestConfig) => {\n  const token = localStorage.getItem('token');\n  if (token && config.headers) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\n\nexport const login = async (username: string, password: string): Promise<LoginResponse> => {\n  const response = await api.post<LoginResponse>('/auth/login', { username, password });\n  return response.data;\n};\n\nexport const createTicket = async (ticketData: Omit<Ticket, 'id' | 'status' | 'createdAt' | 'updatedAt'>): Promise<Ticket> => {\n  const formData = new FormData();\n  \n  // Add ticket data\n  formData.append('title', ticketData.title);\n  formData.append('description', ticketData.description);\n  formData.append('requesterId', ticketData.requesterId);\n  formData.append('department', ticketData.department);\n  formData.append('chemicalConfig', JSON.stringify(ticketData.chemicalConfig));\n  \n  // Add files if they exist\n  if (ticketData.attachments && ticketData.attachments instanceof FileList) {\n    Array.from(ticketData.attachments).forEach(file => {\n      formData.append('files', file);\n    });\n  }\n\n  const response = await api.post<Ticket>('/tickets', formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data',\n    },\n  });\n  return response.data;\n};\n\n// New function to get tickets without date filtering for debugging\nexport const getAllTicketsRaw = async (): Promise<any> => {\n  console.log('Fetching all tickets raw for debugging');\n  const debugInfo: any = {\n    requestInfo: {},\n    responseInfo: {},\n    error: null,\n    attempts: []\n  };\n  \n  try {\n    // Get auth token info\n    const token = localStorage.getItem('token');\n    debugInfo.requestInfo.auth = {\n      hasToken: !!token,\n      tokenLength: token ? token.length : 0,\n      tokenStart: token ? token.substring(0, 10) + '...' : 'none'\n    };\n    \n    // Try multiple variations of API calls to diagnose the issue\n    \n    // Attempt 1: Basic call without params\n    console.log('DEBUG attempt 1: Basic call without params');\n    debugInfo.attempts.push({ \n      name: 'Basic Call', \n      url: '/tickets',\n      params: {},\n      startTime: new Date().toISOString()\n    });\n    \n    let response = await api.get('/tickets');\n    \n    debugInfo.attempts[0].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[0].endTime = new Date().toISOString();\n    \n    // Attempt 2: With pagination params only\n    console.log('DEBUG attempt 2: With pagination params only');\n    const params = {\n      page: '1',\n      limit: '100'\n    };\n    \n    debugInfo.attempts.push({ \n      name: 'Pagination Only', \n      url: '/tickets',\n      params,\n      startTime: new Date().toISOString()\n    });\n    \n    response = await api.get('/tickets', { params });\n    \n    debugInfo.attempts[1].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[1].endTime = new Date().toISOString();\n    \n    // Attempt 3: With modified date range (all time)\n    console.log('DEBUG attempt 3: With all-time date range');\n    const dateParams = {\n      page: '1',\n      limit: '100',\n      startDate: '2020-01-01',\n      endDate: new Date().toISOString()\n    };\n    \n    debugInfo.attempts.push({ \n      name: 'All-Time Date Range', \n      url: '/tickets',\n      params: dateParams,\n      startTime: new Date().toISOString()\n    });\n    \n    response = await api.get('/tickets', { params: dateParams });\n    \n    debugInfo.attempts[2].response = {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n      dataType: typeof response.data,\n      isArray: Array.isArray(response.data),\n      length: Array.isArray(response.data) ? response.data.length : null,\n      data: response.data\n    };\n    debugInfo.attempts[2].endTime = new Date().toISOString();\n    \n    // Return the combined debug info\n    return {\n      success: true,\n      debugInfo,\n      mainResponse: response.data\n    };\n  } catch (error: any) {\n    console.error('Error in raw ticket fetch:', error);\n    debugInfo.error = {\n      message: error.message,\n      stack: error.stack,\n      response: error.response ? {\n        status: error.response.status,\n        statusText: error.response.statusText,\n        data: error.response.data\n      } : null\n    };\n    return { \n      success: false,\n      error: error.message,\n      debugInfo\n    };\n  }\n};\n\nexport const getTickets = async (\n  status?: TicketStatus,\n  page = 1,\n  limit = 10,\n  dateRange?: { startDate: Date; endDate: Date }\n) => {\n  try {\n    // Build query parameters\n    const params: Record<string, string> = {\n      page: page.toString(),\n      limit: limit.toString(),\n    };\n\n    if (status) {\n      params.status = status;\n    }\n\n    // Add date filter parameters if provided\n    if (dateRange) {\n      // Format dates as ISO strings and extract just the date part for consistency\n      params.startDate = dateRange.startDate.toISOString().split('T')[0];\n      \n      // For end date, ensure we're capturing the full day by setting time to end of day\n      const endDate = new Date(dateRange.endDate);\n      endDate.setHours(23, 59, 59, 999);\n      params.endDate = endDate.toISOString();\n      \n      console.log('API call with date range:', { \n        startDate: params.startDate, \n        endDate: params.endDate \n      });\n    } else {\n      console.log('API call with no date range provided');\n    }\n\n    const queryString = new URLSearchParams(params).toString();\n    \n    console.log(`Fetching tickets with params: ${queryString}`);\n    const response = await api.get(`/tickets?${queryString}`);\n    \n    // Add more detailed logging\n    console.log('API response type:', typeof response.data);\n    console.log('API response keys:', Object.keys(response.data || {}));\n    \n    // Check if response has the expected structure\n    if (response.data && response.data.tickets && Array.isArray(response.data.tickets)) {\n      console.log(`Found ${response.data.tickets.length} tickets in response`);\n      return response.data;\n    } \n    \n    // Handle case where response is directly an array of tickets\n    if (Array.isArray(response.data)) {\n      console.log(`Response is an array with ${response.data.length} tickets`);\n      return {\n        tickets: response.data,\n        pagination: {\n          page,\n          limit,\n          total: response.data.length,\n          totalPages: Math.ceil(response.data.length / limit),\n        }\n      };\n    }\n    \n    // Handle empty or unexpected response\n    console.warn('Unexpected response format:', response.data);\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      }\n    };\n  } catch (error: any) {\n    console.error('Error fetching tickets:', error);\n    console.error('Error details:', error.response?.data || error.message);\n    \n    // Return empty data structure instead of throwing\n    return {\n      tickets: [],\n      pagination: {\n        page,\n        limit,\n        total: 0,\n        totalPages: 0\n      },\n      error: error.message\n    };\n  }\n};\n\nexport const updateTicketStatus = async (ticketId: string, status: string): Promise<Ticket> => {\n  const response = await api.put<Ticket>(`/tickets/${ticketId}`, { status });\n  return response.data;\n};\n\nexport const updateTicket = async (ticketId: string, updateData: Partial<Ticket>): Promise<Ticket> => {\n  const formData = new FormData();\n  \n  // Add basic ticket data if provided\n  if (updateData.title) formData.append('title', updateData.title);\n  if (updateData.description) formData.append('description', updateData.description);\n  if (updateData.status) formData.append('status', updateData.status);\n  if (updateData.department) formData.append('department', updateData.department);\n  if (updateData.chemicalConfig) formData.append('chemicalConfig', JSON.stringify(updateData.chemicalConfig));\n  \n  // Add new files if they exist\n  if (updateData.attachments && Array.isArray(updateData.attachments)) {\n    updateData.attachments.forEach(file => {\n      if (file instanceof File) {\n        formData.append('files', file);\n      }\n    });\n  }\n\n  const response = await api.put<Ticket>(`/tickets/${ticketId}`, formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data',\n    },\n  });\n  return response.data;\n};\n\nexport default api; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}